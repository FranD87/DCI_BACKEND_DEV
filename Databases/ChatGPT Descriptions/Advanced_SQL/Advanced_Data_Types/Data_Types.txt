Enumerate Type:

1. CREATE TYPE location_type AS ENUM('Selling point', 'Local office', 'Headquarters');
   - This line creates a new data type called "location_type" with three possible values: 'Selling point',
     'Local office', and 'Headquarters'. This data type represents an ordered set of values.

2. ALTER TABLE area ADD COLUMN type location_type;
   - This line adds a new column named "type" to the existing table "area" with the data type "location_type." This
     column will store the type of location associated with each row.

3. UPDATE area SET type = 'Something else';
   - This update statement attempts to change the value of the "type" column to 'Something else' for all rows in the
     "area" table. However, it results in an error because 'Something else' is not one of the defined values in the
     "location_type" data type.

4. UPDATE area SET type = 'SELLING POINT';
   - This update statement also encounters an error because 'SELLING POINT' does not match the defined values in the
     "location_type" data type. The comparison is case-sensitive, and the correct value should be 'Selling point'
     (in title case).

5. UPDATE area SET type = 'Local office';
   - This update statement successfully changes the value of the "type" column to 'Local office' for all rows in the
     "area" table.

6. UPDATE area SET type = 'Headquarters' WHERE name = 'location A';
   - This update statement changes the value of the "type" column to 'Headquarters' for the row in the "area" table
     where the "name" column is equal to 'location A'.

7. UPDATE area SET type = 'Selling point' WHERE name = 'location D';
   - This update statement changes the value of the "type" column to 'Selling point' for the row in the "area" table
     where the "name" column is equal to 'location D'.

8. SELECT * FROM area ORDER BY type;
   - This query selects all rows from the "area" table and orders them based on the values in the "type" column.

9. SELECT * FROM area WHERE type > 'Selling point';
   - This query selects all rows from the "area" table where the value in the "type" column is greater than 'Selling
     point'.

UUID:

1. SELECT * FROM pg_extension;
   - This query selects all rows from the "pg_extension" table, which contains information about installed extensions
     in the PostgreSQL database.

2. CREATE EXTENSION "uuid-ossp";
   - This line creates the extension "uuid-ossp" in the PostgreSQL database. The "uuid-ossp" extension provides
     functions for generating UUIDs.

3. SELECT * FROM pg_extension;
   - This query is executed after creating the "uuid-ossp" extension to retrieve the updated list of installed
     extensions in the PostgreSQL database. It verifies that the extension has been successfully added.

4. SELECT uuid_generate_v4();
   - This query invokes the function "uuid_generate_v4()" to generate a single random version 4 UUID. Version 4 UUIDs
     are generated based on random numbers and are considered unique.

5. CREATE TABLE user_test (user_uuid uuid DEFAULT uuid_generate_v4(), name VARCHAR(255) NOT NULL, PRIMARY KEY
   (user_uuid));
   - This line creates a new table named "user_test" in the PostgreSQL database. The table has three columns:
     "user_uuid" of type UUID with a default value generated by "uuid_generate_v4()", "name" of type VARCHAR with a
     maximum length of 255 characters, and a primary key constraint on the "user_uuid" column.

6. INSERT INTO user_test (name) VALUES ('JULIA'), ('Anna');
   - This line inserts two rows into the "user_test" table. Each row contains a value for the "name" column
     ('JULIA' and 'Anna'). The "user_uuid" column will be automatically populated with a version 4 UUID generated
     by the default value.

7. SELECT * FROM user_test;
   - This query retrieves all rows from the "user_test" table. It will display the "user_uuid" and "name" columns,
     showing the inserted data.

JSON:

1. ALTER TABLE area ADD COLUMN info JSON;
   - This line adds a new column named "info" to the existing table "area" with the JSON data type. The JSON data type
     stores JSON-formatted data.

2. UPDATE area SET info='{"general": "TRUE", "some_extra_information": "bla-bla-bla"}';
   - This update statement sets the value of the "info" column to a JSON object containing key-value pairs. It includes
     a "general" key with the value "TRUE" and an additional key "some_extra_information" with the value "bla-bla-bla".

3. SELECT info->'general', pg_typeof(info->'general'), info->>'general', pg_typeof(info->>'general') FROM area WHERE
   info->>'general'='TRUE';
     - This query retrieves specific information from the "info" column for rows where the value of the "general" key is
       equal to "TRUE". The four selected fields are:
     - info->'general': Accesses the value of the "general" key as a JSON object.
     - pg_typeof(info->'general'): Retrieves the data type of the "general" key in the JSON object.
     - info->>'general': Extracts the value of the "general" key as a text (string).
     - pg_typeof(info->>'general'): Retrieves the data type of the extracted value from the "general" key.

4. UPDATE area SET info = '{"all": {"ok": true}}' WHERE type = 'Headquarters';
   - This update statement modifies the value of the "info" column for rows where the "type" column is equal to
     "Headquarters". It sets the value of the "info" column to a nested JSON object with a key "all" containing another
     key-value pair "ok": true.

5. SELECT info#>'{all,ok}', pg_typeof(info#>'{all,ok}'), info#>>'{all,ok}', pg_typeof(info#>>'{all,ok}') FROM area
   WHERE info#>>'{all,ok}' = 'true';
     - This query retrieves specific information from the "info" column for rows where the value of the nested key "ok"
       is equal to "true". The four selected fields are:
     - info#>'{all,ok}': Extracts the nested value of the key "ok" as a JSON object.
     - pg_typeof(info#>'{all,ok}'): Retrieves the data type of the extracted nested value.
     - info#>>'{all,ok}': Extracts the nested value of the key "ok" as text (string).
     - pg_typeof(info#>>'{all,ok}'): Retrieves the data type of the extracted nested value.

6. ALTER TABLE area ADD COLUMN infob jsonb;
   - This line adds a new column named "infob" to the existing table "area" with the JSONB data type. JSONB is a binary
     format for JSON data that provides faster processing and more advanced indexing capabilities compared to the JSON
     data type.

7. SELECT name, infob, infob@>'{"all": "ok"}' FROM area;
   - This query selects the "name" and "infob" columns from the "area" table. Additionally, it checks if the JSONB
     value in the "infob" column contains the specified JSON path expression: infob@>'{"all": "ok"}'. The result will
     include rows where the "infob" column has a JSONB value that matches the expression.

8. SELECT name, infob, infob?'all', infob?'something' FROM area;
   - This query selects the "name" and "infob" columns from the "area" table. It also uses the "infob?" operator to
     check if the "infob" JSONB value has specific keys present. The result includes rows with the "name" and "infob"
     columns and additional columns indicating whether the "all" key or the "something" key exists in the "infob" JSONB
     value. The result will display true or false values for each key's existence.

ARRAY:

1. `ALTER TABLE area ADD COLUMN q_earnings integer[];`
     - This statement adds a new column named "q_earnings" to the "area" table. The data type of this column is an array
       of integers (`integer[]`).

2. `ALTER TABLE area ADD COLUMN alternate_name varchar[];`
     - This statement adds another new column named "alternate_name" to the "area" table. The data type of this column is
       an array of varchar (`varchar[]`), which can store an array of string values.

3. `ALTER TABLE area ADD COLUMN boundaries jsonb[];`
     - This statement adds a third new column named "boundaries" to the "area" table. The data type of this column is an
       array of JSON objects (`jsonb[]`), which can store an array of JSON structures.

4. `UPDATE area SET q_earnings = ARRAY[0, 0, 0, 0];`
     - This UPDATE statement sets the values of the "q_earnings" column for all rows in the "area" table to an array with
       four elements, `[0, 0, 0, 0]`. This assigns the same array to all rows.

5. `UPDATE area SET q_earnings = ARRAY[10, 14, 19, 13] WHERE type = 'Headquarters';`
     - This UPDATE statement sets the values of the "q_earnings" column to a different array, `[10, 14, 19, 13]`, but
       only for rows where the "type" column has the value 'Headquarters'. This condition ensures that only specific rows
       are updated with this array.

6. `SELECT name, type, q_earnings[1] AS Q1, q_earnings[2] AS Q2 FROM area WHERE q_earnings[2] > 10;`
     - This SELECT statement retrieves data from the "area" table. It selects the columns "name," "type," and extracts
       specific elements from the "q_earnings" array column. The extracted elements are aliased as "Q1" and "Q2."
       The WHERE clause filters the results to include only rows where the value at index 2 of the "q_earnings" array
       is greater than 10.

7. `ALTER TABLE area ADD COLUMN opened INTEGER [][];`
     - This ALTER TABLE statement adds a new column named "opened" to the "area" table. The data type of this column
       is a two-dimensional array of integers (`INTEGER [][]`).

8. `UPDATE area SET opened = ARRAY[[8, 12], [13, 17]];`
     - This UPDATE statement sets the values of the "opened" column for all rows in the "area" table. It assigns a
       two-dimensional array with specific values to the "opened" column.

9. `UPDATE area SET opened [2][2] = 19 WHERE type = 'Headquarters';`
     - This UPDATE statement modifies the value at a specific index in the "opened" column. It changes the value at
       the second row and second column (index 2) to 19, but only for rows where the "type" column has the value
       'Headquarters'.

10. `UPDATE area SET q_earnings = array_append(q_earnings, 100);`
     - This UPDATE statement appends the value 100 to the "q_earnings" array column for all rows in the "area" table.
       The `array_append` function is used to add the value at the end of the array.

11. `UPDATE area SET q_earnings = array_remove(q_earnings, 100) WHERE type = 'Headquarters';`
     - This UPDATE statement removes the value 100 from the "q_earnings" array column but only for rows where the
       "type" column has the value 'Headquarters'. The `array_remove` function is used to eliminate the specified
       value from the array.

12. `SELECT * FROM area WHERE array_length(q_earnings, 1) > 4;`
     - This SELECT statement retrieves all columns from the "area" table. The WHERE clause filters the results
       to include only rows where the length of the "q_earnings" array is greater than 4 in the first dimension (1).

DATETIME:

1. `ALTER TABLE area ADD COLUMN opened_date date;`
     - This ALTER TABLE statement adds a new column named "opened_date" to the "area" table. The data type of this
       column is "date," which stores date values without time.

2. `UPDATE area SET opened_date = '1999-01-23';`
     - This UPDATE statement assigns the value '1999-01-23' to the "opened_date" column for all rows in the "area"
       table. It sets the same date for all rows.

3. `ALTER TABLE area ADD COLUMN opened_time TIME;`
     - This ALTER TABLE statement adds another new column named "opened_time" to the "area" table. The data type of
       this column is "time," which stores time values without a date component.

4. `UPDATE area SET opened_time = '15:23:59';`
     - This UPDATE statement assigns the value '15:23:59' to the "opened_time" column for all rows in the "area"
       table. It sets the same time for all rows.

5. `ALTER TABLE area ADD COLUMN opened_ts TIMESTAMP;`
     - This ALTER TABLE statement adds a third new column named "opened_ts" to the "area" table. The data type of
       this column is "timestamp," which stores both date and time values.

6. `UPDATE area SET opened_ts = '2004-10-19 10:23:54';`
     - This UPDATE statement assigns the value '2004-10-19 10:23:54' to the "opened_ts" column for all rows in the
       "area" table. It sets the same timestamp for all rows.

7. `SELECT CURRENT_TIMESTAMP - opened_ts AS "Days open" FROM area;`
     - This SELECT statement calculates the difference between the current timestamp (CURRENT_TIMESTAMP) and the
       values in the "opened_ts" column for each row in the "area" table. The result is returned as a column labeled
       "Days open." This calculation can give you the number of days that have passed since the "opened_ts" timestamp
       for each row.